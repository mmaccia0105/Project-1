[
  {
    "objectID": "output.html",
    "href": "output.html",
    "title": "Processing and Manipulating Data",
    "section": "",
    "text": "#|message=FALSE\n#|warning=FALSE\n#|results='hide'\n#|echo=FALSE\n\n# Load in necessary packages here!\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.2.3\n\n\nWarning: package 'ggplot2' was built under R version 4.2.3\n\n\nWarning: package 'tibble' was built under R version 4.2.3\n\n\nWarning: package 'tidyr' was built under R version 4.2.3\n\n\nWarning: package 'readr' was built under R version 4.2.3\n\n\nWarning: package 'purrr' was built under R version 4.2.3\n\n\nWarning: package 'dplyr' was built under R version 4.2.3\n\n\nWarning: package 'stringr' was built under R version 4.2.3\n\n\nWarning: package 'forcats' was built under R version 4.2.3\n\n\nWarning: package 'lubridate' was built under R version 4.2.3\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "output.html#data-processing",
    "href": "output.html#data-processing",
    "title": "Processing and Manipulating Data",
    "section": "Data Processing",
    "text": "Data Processing\n\nFirst Steps: Importing Data\nOur overall goal in this project is to process and manipulate data using common techniques and R packages. In this instance, we are using data from the 2010 census as an example! The first step in any data science project is to read in the data from wherever we are importing it from. In this case, we have some comma separated value (csv) files. Luckily, R makes this pretty easy with the read.csv() function!\n\n#|message=FALSE\n\n# Read in the first dataset using read.csv\ncensus_1 &lt;- read.csv(file = \".\\\\data\\\\EDU01a.csv\", header = TRUE)\n\n# Convert to a tibble for ease of use\ncensus_1 &lt;- as_tibble(census_1)\n\n\n\n1: Selecting Columns\nNow that we have some data to work with, we can use the dplyr package to select the columns we care about and take a look to make sure that everything got read in properly.\n\n# Select Area_name, STCOU, and any column ending with a D\ncensus_1_small &lt;- census_1 |&gt;\n  select(Area_name, STCOU, ends_with(\"D\"))\n\n#View our selection!\nhead(census_1_small, n = 5)\n\n# A tibble: 5 × 12\n  Area_name     STCOU EDU010187D EDU010188D EDU010189D EDU010190D EDU010191D\n  &lt;chr&gt;         &lt;int&gt;      &lt;int&gt;      &lt;int&gt;      &lt;int&gt;      &lt;int&gt;      &lt;int&gt;\n1 UNITED STATES     0   40024299   39967624   40317775   40737600   41385442\n2 ALABAMA        1000     733735     728234     730048     728252     725541\n3 Autauga, AL    1001       6829       6900       6920       6847       7008\n4 Baldwin, AL    1003      16417      16465      16799      17054      17479\n5 Barbour, AL    1005       5071       5098       5068       5156       5173\n# ℹ 5 more variables: EDU010192D &lt;int&gt;, EDU010193D &lt;int&gt;, EDU010194D &lt;int&gt;,\n#   EDU010195D &lt;int&gt;, EDU010196D &lt;int&gt;\n\n\nLooks good!\n\n\n2: Pivoting Data\nThere is some information stored in the column names that we care about in our data, and it isn’t exactly easy to analyze that data when it’s stored in the name. As such, we are going to pivot this data into a longer dataframe.\n\n#Pivot longer so that we can access data stored in some column names\ncensus_1_long &lt;- census_1_small |&gt;\n  pivot_longer(cols = 3:12,\n               names_to = \"enrollment\",\n               values_to = \"count\")\n\n#View results!\nhead(census_1_long, n = 5)\n\n# A tibble: 5 × 4\n  Area_name     STCOU enrollment    count\n  &lt;chr&gt;         &lt;int&gt; &lt;chr&gt;         &lt;int&gt;\n1 UNITED STATES     0 EDU010187D 40024299\n2 UNITED STATES     0 EDU010188D 39967624\n3 UNITED STATES     0 EDU010189D 40317775\n4 UNITED STATES     0 EDU010190D 40737600\n5 UNITED STATES     0 EDU010191D 41385442\n\n\nNotice how there is only one measurement per row now!\n\n\n3: Parsing Strings\nLet’s take a closer look at the enrollment column now. According to the data information sheet provided, the first three letters and first four numbers represent the type of survey that was completed. For example, row one has the value EDU0101 which represents school enrollment. The next two digits represent the year the survey was taken. Using the first row as an example again, we see that those two digits are 87, meaning that the survey was taken in 1987. We can parse this column to get some meaningful data year-over-year.\n\n#Parse the enrollment column:\n#enrollment - first three letters plus first four digits (ex. EDU0101)\n#year - next two digits (ex. 87 becomes 1987)\ncensus_1_long_updated &lt;- census_1_long |&gt;\n  mutate(year = substr(enrollment, 8, 9),\n         enrollment = substr(enrollment, 1, 7)) |&gt;\n  #Add 1900 (or 2000) to the year column to get the YYYY instead of YY\n  mutate(year = case_when(\n    as.numeric(year) &gt;= 87 ~ 1900 + as.numeric(year),\n    .default = 2000 + as.numeric(year)\n    )\n  )\n\n#View results!\nhead(census_1_long_updated, n = 5)\n\n# A tibble: 5 × 5\n  Area_name     STCOU enrollment    count  year\n  &lt;chr&gt;         &lt;int&gt; &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt;\n1 UNITED STATES     0 EDU0101    40024299  1987\n2 UNITED STATES     0 EDU0101    39967624  1988\n3 UNITED STATES     0 EDU0101    40317775  1989\n4 UNITED STATES     0 EDU0101    40737600  1990\n5 UNITED STATES     0 EDU0101    41385442  1991\n\n\nNow we have two columns to explain the survey information in a more intuitive manner.\n\n\n4: Splitting the Dataset\nNote that when we first imported the dataset, we saw that there was data for the country as a whole, as well as individual states as well as the counties within the states. If we wished to analyze the data, it may make more sense to be able to easily subset it by county and non-county data so we can get better insights. As such, let’s split the data into a county set and a non-county set. We can use dplyr’s slice() function to accomplish this, using an expression provided that returns the indices of all rows that match a given condition!\n\n#Filter tibble into two separate tibbles using county as the identifier\ncounty_1 &lt;- census_1_long_updated |&gt;\n  slice(grep(pattern = \", \\\\w\\\\w\", Area_name))\n\n#We can invert using the 'invert' argument in grep() as well\nnon_county_1 &lt;- census_1_long_updated |&gt;\n  slice(grep(pattern = \", \\\\w\\\\w\", Area_name, invert = TRUE))\n\n#Add the custom classes to the tibbles for future use\nclass(county_1) &lt;- c(\"county\", class(county_1))\nclass(non_county_1) &lt;- c(\"state\", class(non_county_1))\n\nhead(county_1, n = 10)\n\n# A tibble: 10 × 5\n   Area_name   STCOU enrollment count  year\n   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt;\n 1 Autauga, AL  1001 EDU0101     6829  1987\n 2 Autauga, AL  1001 EDU0101     6900  1988\n 3 Autauga, AL  1001 EDU0101     6920  1989\n 4 Autauga, AL  1001 EDU0101     6847  1990\n 5 Autauga, AL  1001 EDU0101     7008  1991\n 6 Autauga, AL  1001 EDU0101     7137  1992\n 7 Autauga, AL  1001 EDU0101     7152  1993\n 8 Autauga, AL  1001 EDU0101     7381  1994\n 9 Autauga, AL  1001 EDU0101     7568  1995\n10 Autauga, AL  1001 EDU0101     7834  1996\n\nhead(non_county_1, n = 10)\n\n# A tibble: 10 × 5\n   Area_name     STCOU enrollment    count  year\n   &lt;chr&gt;         &lt;int&gt; &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt;\n 1 UNITED STATES     0 EDU0101    40024299  1987\n 2 UNITED STATES     0 EDU0101    39967624  1988\n 3 UNITED STATES     0 EDU0101    40317775  1989\n 4 UNITED STATES     0 EDU0101    40737600  1990\n 5 UNITED STATES     0 EDU0101    41385442  1991\n 6 UNITED STATES     0 EDU0101    42088151  1992\n 7 UNITED STATES     0 EDU0101    42724710  1993\n 8 UNITED STATES     0 EDU0101    43369917  1994\n 9 UNITED STATES     0 EDU0101    43993459  1995\n10 UNITED STATES     0 EDU0101    44715737  1996\n\n\n\n\n5: Subsetting Strings in the County Data\nWe may want to subset by state in our analysis, so let’s subset the county data to separate the county’s name and state by using the comma as a delimiter.\n\n#Split the county name and state using , as a delimiter\ncounty_1_split &lt;- county_1 |&gt;\n  # separate() indicates that it is superseded per help file\n  # Using separate_wider_delim() in favor of separate()\n  separate_wider_delim(Area_name, \",\", names = c(\"county\", \"state\")) |&gt;\n  # Trim the whitespace on the state column\n  mutate(state = trimws(state))\n\n#View results\nhead(county_1_split, n = 5)\n\n# A tibble: 5 × 6\n  county  state STCOU enrollment count  year\n  &lt;chr&gt;   &lt;chr&gt; &lt;int&gt; &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt;\n1 Autauga AL     1001 EDU0101     6829  1987\n2 Autauga AL     1001 EDU0101     6900  1988\n3 Autauga AL     1001 EDU0101     6920  1989\n4 Autauga AL     1001 EDU0101     6847  1990\n5 Autauga AL     1001 EDU0101     7008  1991"
  }
]