[
  {
    "objectID": "output.html",
    "href": "output.html",
    "title": "Processing and Manipulating Data",
    "section": "",
    "text": "#|message=FALSE\n#|warning=FALSE\n\n# Load in necessary packages here!\nsuppressPackageStartupMessages(library(tidyverse))"
  },
  {
    "objectID": "output.html#data-processing",
    "href": "output.html#data-processing",
    "title": "Processing and Manipulating Data",
    "section": "Data Processing",
    "text": "Data Processing\n\nFirst Steps: Importing Data\nOur overall goal in this project is to process and manipulate data using common techniques and R packages. In this instance, we are using data from the 2010 census as an example! The first step in any data science project is to read in the data from wherever we are importing it from. In this case, we have some comma separated value (csv) files. Luckily, R makes this pretty easy with the read.csv() function!\n\n#|message=FALSE\n\n# Read in the first dataset using read.csv\ncensus_1 &lt;- read.csv(file = \"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\", header = TRUE)\n\n# Convert to a tibble for ease of use\ncensus_1 &lt;- as_tibble(census_1)\n\n\n\n1: Selecting Columns\nNow that we have some data to work with, we can use the dplyr package to select the columns we care about and take a look to make sure that everything got read in properly.\n\n# Select Area_name, STCOU, and any column ending with a D\ncensus_1_small &lt;- census_1 |&gt;\n  select(Area_name, STCOU, ends_with(\"D\")) |&gt; \n    rename(area_name = Area_name) #rename variable\n\n#View our selection!\nhead(census_1_small, n = 5)\n\n# A tibble: 5 × 12\n  area_name     STCOU EDU010187D EDU010188D EDU010189D EDU010190D EDU010191D\n  &lt;chr&gt;         &lt;int&gt;      &lt;int&gt;      &lt;int&gt;      &lt;int&gt;      &lt;int&gt;      &lt;int&gt;\n1 UNITED STATES     0   40024299   39967624   40317775   40737600   41385442\n2 ALABAMA        1000     733735     728234     730048     728252     725541\n3 Autauga, AL    1001       6829       6900       6920       6847       7008\n4 Baldwin, AL    1003      16417      16465      16799      17054      17479\n5 Barbour, AL    1005       5071       5098       5068       5156       5173\n# ℹ 5 more variables: EDU010192D &lt;int&gt;, EDU010193D &lt;int&gt;, EDU010194D &lt;int&gt;,\n#   EDU010195D &lt;int&gt;, EDU010196D &lt;int&gt;\n\n\nLooks good!\n\n\n2: Pivoting Data\nThere is some information stored in the column names that we care about in our data, and it isn’t exactly easy to analyze that data when it’s stored in the name. As such, we are going to pivot this data into a longer dataframe.\n\n#Pivot longer so that we can access data stored in some column names\ncensus_1_long &lt;- census_1_small |&gt;\n  pivot_longer(cols = 3:12,\n               names_to = \"survey_ID\",\n               values_to = \"enrollment\")\n\n#View results!\nhead(census_1_long, n = 5)\n\n# A tibble: 5 × 4\n  area_name     STCOU survey_ID  enrollment\n  &lt;chr&gt;         &lt;int&gt; &lt;chr&gt;           &lt;int&gt;\n1 UNITED STATES     0 EDU010187D   40024299\n2 UNITED STATES     0 EDU010188D   39967624\n3 UNITED STATES     0 EDU010189D   40317775\n4 UNITED STATES     0 EDU010190D   40737600\n5 UNITED STATES     0 EDU010191D   41385442\n\n\nNotice how there is only one measurement per row now!\n\n\n3: Parsing Strings\nLet’s take a closer look at the survey_ID column now. According to the data information sheet provided, the first three letters and first four numbers represent the type of survey that was completed. For example, row one has the value EDU0101 which represents school survey_ID. The next two digits represent the year the survey was taken. Using the first row as an example again, we see that those two digits are 87, meaning that the survey was taken in 1987. We can parse this column to get some meaningful data year-over-year.\n\n#Parse the survey_ID column:\n#survey_ID - first three letters plus first four digits (ex. EDU0101)\n#year - next two digits (ex. 87 becomes 1987)\nlong_updated &lt;- census_1_long |&gt;\n  mutate(year = substr(survey_ID, 8, 9),\n         survey_ID = substr(survey_ID, 1, 7)) |&gt;\n  #Add 1900 (or 2000) to the year column to get the YYYY instead of YY\n  mutate(year = case_when(\n    as.numeric(year) &gt;= 87 ~ 1900 + as.numeric(year),\n    .default = 2000 + as.numeric(year)\n    )\n  )\n\n#View results!\nhead(long_updated, n = 5)\n\n# A tibble: 5 × 5\n  area_name     STCOU survey_ID enrollment  year\n  &lt;chr&gt;         &lt;int&gt; &lt;chr&gt;          &lt;int&gt; &lt;dbl&gt;\n1 UNITED STATES     0 EDU0101     40024299  1987\n2 UNITED STATES     0 EDU0101     39967624  1988\n3 UNITED STATES     0 EDU0101     40317775  1989\n4 UNITED STATES     0 EDU0101     40737600  1990\n5 UNITED STATES     0 EDU0101     41385442  1991\n\n\nNow we have two columns to explain the survey information in a more intuitive manner.\n\n\n4: Splitting the Dataset\nNote that when we first imported the dataset, we saw that there was data for the country as a whole, as well as individual states as well as the counties within the states. If we wished to analyze the data, it may make more sense to be able to easily subset it by county and non-county data so we can get better insights. As such, let’s split the data into a county set and a non-county set. We can use dplyr’s slice() function to accomplish this, using an expression provided that returns the indices of all rows that match a given condition!\n\n#Filter tibble into two separate tibbles using county as the identifier\ncounty_1 &lt;- long_updated |&gt;\n  slice(grep(pattern = \", \\\\w\\\\w\", area_name))\n\n#We can invert using the 'invert' argument in grep() as well\nnon_county_1 &lt;- long_updated |&gt;\n  slice(grep(pattern = \", \\\\w\\\\w\", area_name, invert = TRUE))\n\n#Add the custom classes to the tibbles for future use\nclass(county_1) &lt;- c(\"county\", class(county_1))\nclass(non_county_1) &lt;- c(\"state\", class(non_county_1))\n\nhead(county_1, n = 10)\n\n# A tibble: 10 × 5\n   area_name   STCOU survey_ID enrollment  year\n   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;          &lt;int&gt; &lt;dbl&gt;\n 1 Autauga, AL  1001 EDU0101         6829  1987\n 2 Autauga, AL  1001 EDU0101         6900  1988\n 3 Autauga, AL  1001 EDU0101         6920  1989\n 4 Autauga, AL  1001 EDU0101         6847  1990\n 5 Autauga, AL  1001 EDU0101         7008  1991\n 6 Autauga, AL  1001 EDU0101         7137  1992\n 7 Autauga, AL  1001 EDU0101         7152  1993\n 8 Autauga, AL  1001 EDU0101         7381  1994\n 9 Autauga, AL  1001 EDU0101         7568  1995\n10 Autauga, AL  1001 EDU0101         7834  1996\n\nhead(non_county_1, n = 10)\n\n# A tibble: 10 × 5\n   area_name     STCOU survey_ID enrollment  year\n   &lt;chr&gt;         &lt;int&gt; &lt;chr&gt;          &lt;int&gt; &lt;dbl&gt;\n 1 UNITED STATES     0 EDU0101     40024299  1987\n 2 UNITED STATES     0 EDU0101     39967624  1988\n 3 UNITED STATES     0 EDU0101     40317775  1989\n 4 UNITED STATES     0 EDU0101     40737600  1990\n 5 UNITED STATES     0 EDU0101     41385442  1991\n 6 UNITED STATES     0 EDU0101     42088151  1992\n 7 UNITED STATES     0 EDU0101     42724710  1993\n 8 UNITED STATES     0 EDU0101     43369917  1994\n 9 UNITED STATES     0 EDU0101     43993459  1995\n10 UNITED STATES     0 EDU0101     44715737  1996\n\n\n\n\n5: Splitting Strings in the County Data\nWe may want to subset by state in our analysis, so let’s subset the county data to separate the county’s name and state by using the comma as a delimiter.\n\n#Split the county name and state using , as a delimiter\ncounty_1_split &lt;- county_1 |&gt;\n  # separate() indicates that it is superseded per help file\n  # Using separate_wider_delim() in favor of separate()\n  separate_wider_delim(area_name, \",\", names = c(\"county\", \"state\")) |&gt;\n  # Trim the whitespace on the state column\n  mutate(state = trimws(state))\n\n#View results\nhead(county_1_split, n = 5)\n\n# A tibble: 5 × 6\n  county  state STCOU survey_ID enrollment  year\n  &lt;chr&gt;   &lt;chr&gt; &lt;int&gt; &lt;chr&gt;          &lt;int&gt; &lt;dbl&gt;\n1 Autauga AL     1001 EDU0101         6829  1987\n2 Autauga AL     1001 EDU0101         6900  1988\n3 Autauga AL     1001 EDU0101         6920  1989\n4 Autauga AL     1001 EDU0101         6847  1990\n5 Autauga AL     1001 EDU0101         7008  1991\n\n\n\n\n6: Designating Regions in Non-County Data\nSimilar to what we did in the county data above, we can describe the non-county data by larger groups. For the county data, this was the state each county was located in. For the non-county data, it will be the the divisions described by the Census Bureau’s designation. In other words, there are nine defined divisions that the Census Bureau that could be useful for our analysis. In order to indicate divisions we will have to use the case_when function in conjunction with the %in% operator to check and see if each entry is contained within a specific list of states belonging to a division.\n\n#Create string vectors of the states for clarity in the mutate call\nne &lt;- c(\"CONNECTICUT\", \"MAINE\", \"MASSACHUSETTS\", \n        \"NEW HAMPSHIRE\", \"RHODE ISLAND\", \"VERMONT\")\nma &lt;- c(\"NEW JERSEY\", \"NEW YORK\", \"PENNSYLVANIA\")\nenc &lt;- c(\"ILLINOIS\", \"INDIANA\", \"MICHIGAN\", \"OHIO\", \"WISCONSIN\")\nwnc &lt;- c(\"IOWA\", \"KANSAS\", \"MINNESOTA\", \n         \"MISSOURI\", \"NEBRASKA\", \"NORTH DAKOTA\", \n         \"SOUTH DAKOTA\")\nsa &lt;- c(\"DELAWARE\", \"DISTRICT OF COLUMBIA\", \"FLORIDA\",\n        \"GEORGIA\", \"MARYLAND\", \"NORTH CAROLINA\",\n        \"SOUTH CAROLINA\", \"VIRGINIA\", \"WEST VIRGINIA\")\nesc &lt;- c(\"ALABAMA\", \"KENTUCKY\", \"MISSISSIPPI\", \"TENNESSEE\")\nwsc &lt;- c(\"ARKANSAS\", \"LOUISIANA\", \"OKLAHOMA\", \"TEXAS\")\nmtn &lt;- c(\"ARIZONA\", \"COLORADO\", \"IDAHO\", \n         \"MONTANA\", \"NEVADA\", \"NEW MEXICO\", \n         \"UTAH\", \"WYOMING\")\npac &lt;- c(\"ALASKA\", \"CALIFORNIA\", \"HAWAII\", \"OREGON\", \"WASHINGTON\")\n\n# Add the division variable to indicate Census-designated divisions\nnon_county_1_div &lt;- non_county_1 |&gt;\n  mutate(division = case_when(\n    area_name %in% ne ~ \"New England\",\n    area_name %in% ma ~ \"Mid-Atlantic\",\n    area_name %in% enc ~ \"East North Central\",\n    area_name %in% wnc ~ \"West North Central\",\n    area_name %in% sa ~ \"South Atlantic\",\n    area_name %in% esc ~ \"East South Central\",\n    area_name %in% wsc ~ \"West South Central\",\n    area_name %in% mtn ~ \"Mountain\",\n    area_name %in% pac ~ \"Pacific\",\n    .default = \"ERROR\"\n  ))\n\n#View results from the end \n#since the US data is first and will return ERROR\ntail(non_county_1_div, n = 5)\n\n# A tibble: 5 × 6\n  area_name STCOU survey_ID enrollment  year division\n  &lt;chr&gt;     &lt;int&gt; &lt;chr&gt;          &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   \n1 WYOMING   56000 EDU0101       101715  1992 Mountain\n2 WYOMING   56000 EDU0101       100729  1993 Mountain\n3 WYOMING   56000 EDU0101       100899  1994 Mountain\n4 WYOMING   56000 EDU0101       100369  1995 Mountain\n5 WYOMING   56000 EDU0101        99859  1996 Mountain\n\n\nWith that, we’ve done everything that we’ll need to do for our analysis! However, there is one key step that we need to do to make this process easily reproducible."
  },
  {
    "objectID": "output.html#generalizing-into-function-calls",
    "href": "output.html#generalizing-into-function-calls",
    "title": "Processing and Manipulating Data",
    "section": "Generalizing into Function Calls",
    "text": "Generalizing into Function Calls\nThis census data has two key characteristics that are relevant right now: the data that is imported follows the same general format, and we want to process the data in several different ways. That is, we want to easily be able to do the same processes without having to do a bunch of copying-and-pasting work. Luckily, we can write our own functions to take care of that!\nThere will have to be some generalizations made. For example, what if we want to observe data for a different metric? The census takes record of many different aspects of American demographics, and we may be interested in analyzing a different survey one day. Also, the latest observations that we have in the data we read in previously are from 1996, which is almost 30 years ago! We will want to read in some more recent records as well to get a bigger picture on survey_ID data.\nSo, we will write functions to generalize the processes performed above, and we will write a function to merge datasets in order to congregate our newer and older data in one (well, two, because we still want to split the data by county status) data frame(s)!\n\n#---STATE STRINGS---\n#We will need these again for one of the helper functions\nne &lt;- c(\"CONNECTICUT\", \"MAINE\", \"MASSACHUSETTS\", \n        \"NEW HAMPSHIRE\", \"RHODE ISLAND\", \"VERMONT\")\nma &lt;- c(\"NEW JERSEY\", \"NEW YORK\", \"PENNSYLVANIA\")\nenc &lt;- c(\"ILLINOIS\", \"INDIANA\", \"MICHIGAN\", \"OHIO\", \"WISCONSIN\")\nwnc &lt;- c(\"IOWA\", \"KANSAS\", \"MINNESOTA\", \n         \"MISSOURI\", \"NEBRASKA\", \"NORTH DAKOTA\", \n         \"SOUTH DAKOTA\")\nsa &lt;- c(\"DELAWARE\", \"DISTRICT OF COLUMBIA\", \"FLORIDA\",\n        \"GEORGIA\", \"MARYLAND\", \"NORTH CAROLINA\",\n        \"SOUTH CAROLINA\", \"VIRGINIA\", \"WEST VIRGINIA\")\nesc &lt;- c(\"ALABAMA\", \"KENTUCKY\", \"MISSISSIPPI\", \"TENNESSEE\")\nwsc &lt;- c(\"ARKANSAS\", \"LOUISIANA\", \"OKLAHOMA\", \"TEXAS\")\nmtn &lt;- c(\"ARIZONA\", \"COLORADO\", \"IDAHO\", \n         \"MONTANA\", \"NEVADA\", \"NEW MEXICO\", \n         \"UTAH\", \"WYOMING\")\npac &lt;- c(\"ALASKA\", \"CALIFORNIA\", \"HAWAII\", \"OREGON\", \"WASHINGTON\")\n\n#---HELPER FUNCTIONS---\n#This is steps 1 and 2, selecting columns and pivoting data\nselect_and_pivot &lt;- function(tib, name) {\n  #Step 1: Select Columns\n  result &lt;- tib |&gt;\n    select(Area_name, STCOU, ends_with(\"D\")) |&gt;\n    rename(area_name = Area_name) |&gt; #rename variable  \n    pivot_longer(cols = 3:12,\n                 names_to = \"survey_ID\",\n                 values_to = name)\n  \n  return(result)\n}\n\n#This is step 3, where we parse the old column names in survey_ID \n# as well as the survey_stat_name column\nparse_survey_ID &lt;- function(tib) {\n  result &lt;- tib |&gt;\n  mutate(year = substr(survey_ID, 8, 9),\n         survey_ID = substr(survey_ID, 1, 7)) |&gt;\n  #Add 1900 (or 2000) to the year column to get the YYYY instead of YY\n  mutate(year = case_when(\n    as.numeric(year) &gt;= 87 ~ 1900 + as.numeric(year),\n    .default = 2000 + as.numeric(year)\n    )\n  )\n    \n  return(result)\n}\n\n#This is steps 4-6, where we split data and did some more parsing of strings\nsplit_by_county_status &lt;- function(tib) {\n  #Take the county data and add state column\n  result_c &lt;- tib |&gt;\n    slice(grep(pattern = \", \\\\w\\\\w\", area_name)) |&gt;\n    # separate() indicates that it is superseded per help file\n    # Using separate_wider_delim() in favor of separate()\n    separate_wider_delim(area_name, \",\", names = c(\"county\", \"state\")) |&gt;\n    # Trim the whitespace on the state column\n    mutate(state = trimws(state))\n  \n  #Add custom county class\n  class(result_c) &lt;- c(\"county\", class(result_c))\n  \n  #Take the non-county data and add division column\n  result_nc &lt;- tib |&gt;\n    slice(grep(pattern = \", \\\\w\\\\w\", area_name, invert = TRUE)) |&gt;\n    mutate(division = case_when(\n    area_name %in% ne ~ \"New England\",\n    area_name %in% ma ~ \"Mid-Atlantic\",\n    area_name %in% enc ~ \"East North Central\",\n    area_name %in% wnc ~ \"West North Central\",\n    area_name %in% sa ~ \"South Atlantic\",\n    area_name %in% esc ~ \"East South Central\",\n    area_name %in% wsc ~ \"West South Central\",\n    area_name %in% mtn ~ \"Mountain\",\n    area_name %in% pac ~ \"Pacific\",\n    .default = \"ERROR\"\n  ))\n  \n  #Add custom state class\n  class(result_nc) &lt;- c(\"state\", class(result_nc))\n  \n  #Return a list of two tibbles\n  return(list(result_c, result_nc))\n}\n\n#---MAIN FUNCTION CALL---\n#This just calls all the helper functions in order \n#and returns the final product\nprocess_census_data &lt;- function(url, survey_stat_name = \"enrollment\") {\n  #Quick sanity check to make sure we have a character string\n  if (!is.character(url)) {\n    stop(\"url argument must be a character string!\")\n  }\n  \n  #Run through the helper functions and return the results\n  result &lt;- as_tibble(read.csv(file = url, header = TRUE)) |&gt;\n   select_and_pivot(name = survey_stat_name) |&gt;\n   parse_survey_ID() |&gt;\n   split_by_county_status()\n  \n  #Retuns a list of 2 tibbles\n  return(result)\n}\n\n#---DATA COMBINING FUNCTION---\n#This will take two lists of two tibbles each and\n# combine them into one list of two tibbles\n\ncombine_census_data &lt;- function(x, y)  {\n  #Sanity checks: make sure each list is a list of size 2\n  if(!is_tibble(x[[1]]) || !is_tibble(x[[2]])) {\n    stop(\"First list argument does not exclusively contain tibbles.\")\n  }\n  \n  if(!is_tibble(y[[1]]) || !is_tibble(y[[2]])) {\n    stop(\"Second list argument does not exclusively contain tibbles.\")\n  }\n  \n  if(length(x) != length(y) || length(x) != 2) {\n    stop(\"Lists must be of length 2. Current length: \", length(x))\n  }\n  \n  #Combine the first element of each list (county data) together\n  result_c &lt;- bind_rows(x[[1]], y[[1]])\n  #Combine the second element of each list (non-county data) together\n  result_nc &lt;- bind_rows(x[[2]], y[[2]])\n  \n  #Return the result datasets!\n  return(list(result_c, result_nc))\n}\n\nNow that we’ve written our functions, all that’s left to do is call them. If everything works properly, we should see a list of two different tibbles: one with county data from 1987-2006, and another with non-county data from 1987-2006. These datasets should be formatted exactly like the example data we used above!\n\n#Call the functions we just made!\nlist1 &lt;- process_census_data(url = \"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\", survey_stat_name = \"enrollment_count\")\nlist2 &lt;- process_census_data(url = \"https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv\", survey_stat_name = \"enrollment_count\")\n\n#Combine the two lists together\ncensus &lt;- combine_census_data(list1, list2)\n\nLet’s do a quick sort and take a look at some of the data to see if everything looks okay.\n\n#View results\ncensus[[1]] |&gt;\n  arrange(county, year) |&gt;\n  head(n = 20)\n\n# A tibble: 20 × 6\n   county    state STCOU survey_ID enrollment_count  year\n   &lt;chr&gt;     &lt;chr&gt; &lt;int&gt; &lt;chr&gt;                &lt;int&gt; &lt;dbl&gt;\n 1 Abbeville SC    45001 EDU0101               3941  1987\n 2 Abbeville SC    45001 EDU0101               3934  1988\n 3 Abbeville SC    45001 EDU0101               3880  1989\n 4 Abbeville SC    45001 EDU0101               3834  1990\n 5 Abbeville SC    45001 EDU0101               3806  1991\n 6 Abbeville SC    45001 EDU0101               3780  1992\n 7 Abbeville SC    45001 EDU0101               3804  1993\n 8 Abbeville SC    45001 EDU0101               3750  1994\n 9 Abbeville SC    45001 EDU0101               3780  1995\n10 Abbeville SC    45001 EDU0101               3803  1996\n11 Abbeville SC    45001 EDU0101               3821  1997\n12 Abbeville SC    45001 EDU0101               3730  1998\n13 Abbeville SC    45001 EDU0101               3861  1999\n14 Abbeville SC    45001 EDU0102               3927  2000\n15 Abbeville SC    45001 EDU0102               3871  2001\n16 Abbeville SC    45001 EDU0102               3967  2002\n17 Abbeville SC    45001 EDU0152               3812  2003\n18 Abbeville SC    45001 EDU0152               3777  2004\n19 Abbeville SC    45001 EDU0152               3680  2005\n20 Abbeville SC    45001 EDU0152               3616  2006\n\n\nLooks good on the county side. Let’s check the non-counties as well.\n\n#View results, from the end this time for the sake of it.\ncensus[[2]] |&gt;\n  arrange(division, area_name, year) |&gt;\n  tail(n = 20)\n\n# A tibble: 20 × 6\n   area_name STCOU survey_ID enrollment_count  year division          \n   &lt;chr&gt;     &lt;int&gt; &lt;chr&gt;                &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;             \n 1 TEXAS     48000 EDU0101            3209515  1987 West South Central\n 2 TEXAS     48000 EDU0101            3236867  1988 West South Central\n 3 TEXAS     48000 EDU0101            3282956  1989 West South Central\n 4 TEXAS     48000 EDU0101            3268933  1990 West South Central\n 5 TEXAS     48000 EDU0101            3382509  1991 West South Central\n 6 TEXAS     48000 EDU0101            3464371  1992 West South Central\n 7 TEXAS     48000 EDU0101            3535742  1993 West South Central\n 8 TEXAS     48000 EDU0101            3601839  1994 West South Central\n 9 TEXAS     48000 EDU0101            3670193  1995 West South Central\n10 TEXAS     48000 EDU0101            3740260  1996 West South Central\n11 TEXAS     48000 EDU0101            3828975  1997 West South Central\n12 TEXAS     48000 EDU0101            3891877  1998 West South Central\n13 TEXAS     48000 EDU0101            3945367  1999 West South Central\n14 TEXAS     48000 EDU0102            3991783  2000 West South Central\n15 TEXAS     48000 EDU0102            4059619  2001 West South Central\n16 TEXAS     48000 EDU0102            4163447  2002 West South Central\n17 TEXAS     48000 EDU0152            4331751  2003 West South Central\n18 TEXAS     48000 EDU0152            4405215  2004 West South Central\n19 TEXAS     48000 EDU0152            4525394  2005 West South Central\n20 TEXAS     48000 EDU0152            4599509  2006 West South Central\n\n\nLooks good here, too. Now that we have a way to easily process the data we are looking for, it’s time to start thinking about how we are going to summarize and analyze it."
  },
  {
    "objectID": "output.html#using-functions-to-summarize-data",
    "href": "output.html#using-functions-to-summarize-data",
    "title": "Processing and Manipulating Data",
    "section": "Using Functions to Summarize Data",
    "text": "Using Functions to Summarize Data\nWe will start by plotting the data based on state as the location. Our plan is to create a function that plots the mean value of enrollment count across the years for each Division.\n\n#make function as directed\nplot.state &lt;- function(df, var_name=\"enrollment_count\") { \n  \ndf |&gt; #inputting our intended data frame\n    filter(division != \"ERROR\") |&gt;  #removing error values from division\n    group_by(year, division) |&gt;  #grouping by year then divison\n    summarise(mean_value = mean(get(var_name), na.rm=T), .groups =\"drop\")  |&gt; #getting mean of                                                                                           #enrollment count\n    ggplot(aes(x=year, y=mean_value, color=division)) + #aesthetics of plot, followed by a line plot\n    geom_line() \n  \n}\n\n\n#Making sure function is working\nplot.state(census[[2]],var_name = \"enrollment_count\")\n\n\n\n\n\n\n\n\nNext we are going to create a plotting function for the county level data. The goal of this function will be for the user to be able to input the state of interest (with a default value if not specified), determine whether to ‘top’ or bottom most counties are the target (default of ‘top’), and finally an instruction to determine how many of the ‘top’ or bottom most counties should be investigated (default of 5).\n\nplot.county &lt;- function(df, var_name = \"enrollment_count\", \n                        state.name=\"NC\", \n                        top_bottom = \"top\", \n                        n_counties = 5) {\n  \n#filter data by state\nstate_data &lt;- df |&gt; \n  filter(state == state.name)\n\n#calculate mean of the chosen variable (default enrollment_count) for each county. \ncounty_means &lt;- state_data |&gt; \n  group_by(county) |&gt; \n  summarise(mean_var_name = mean(get(var_name), na.rm=TRUE), .groups=\"drop\")\n\n#using the mean value, sort base on if top or bottom is requested\n#then slice based on number of counties requested\nsorted_county_means &lt;- if (top_bottom == \"top\") {\n  county_means |&gt; \n    arrange(desc(mean_var_name))\n      } else {\n  county_means |&gt; \n    arrange(mean_var_name) \n  } \n\n#pull out counties based on chosen rank and n\nselected_counties &lt;- sorted_county_means |&gt;  \n  slice_head (n = n_counties) |&gt; \n  pull (county)\n\n#Use initial data then filter from the subset after calculating means\nplot_data &lt;- state_data |&gt; \n  filter(county %in% selected_counties)\n\n#Plot the values\nggplot(plot_data, aes(x = year, y= get(var_name), color = county)) +\n         geom_line()\n\n}\n\n\nplot.county(census[[1]],var_name = \"enrollment_count\", \n                        state.name=\"WA\", \n                        top_bottom = \"bottom\", \n                        n_counties = 4)"
  }
]